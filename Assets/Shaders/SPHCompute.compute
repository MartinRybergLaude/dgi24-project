#pragma kernel Integrate // Use the force of each particle to move particle
#pragma kernel ComputeForces // Compute forces for each particle
#pragma kernel ComputeDensityPressure // Compute density/pressure for each particle
#pragma kernel HashParticles
#pragma kernel BitonicSort
#pragma kernel CalculateCellOffsets

struct Particle {
    float pressure;
    float density;
    float3 currentForce;
    float3 velocity;
    float3 position;
};

RWStructuredBuffer<Particle> _particles;
RWStructuredBuffer<uint> _particleIndexArray;
RWStructuredBuffer<uint> _cellIndexArray;
RWStructuredBuffer<uint> _cellOffset;

// Variable Declarations 

float particleMass;
float viscosity;
float gasConstant;
float restDensity;
float boundDamping;
float radius;
float radius2;
float radius3;
float radius4;
float radius5;
float pi;
uint particleLength;
float timestep;
float3 boxSize;
float3 spherePos;
float sphereRadius;
int sortBlock;
int sortDim;

int3 GetCellVector (float3 pos) {
    return int3((pos.x + boxSize.x/2)/radius, (pos.y + boxSize.y/2)/radius, (pos.z + boxSize.z/2)/radius);
}

inline uint CellHash (in int3 index) {

    //Large primes to use for hash function
    const uint p1 = 23572337;
    const uint p2 = 74207281;
    const uint p3 = 41312111;

    return ((p1 * index.x ^ p2 * index.y ^ p3 * index.z)%particleLength);
}

[numthreads(256,1,1)]
void HashParticles (uint3 id: SV_DISPATCHTHREADID) {
    _cellOffset[id.x] = 99999999;
    uint index = _particleIndexArray[id.x];
    _cellIndexArray[index] = CellHash(GetCellVector(_particles[index].position));
}

[numthreads(256,1,1)]
void BitonicSort (uint3 id: SV_DISPATCHTHREADID) {
    uint i = id.x + id.y * 256 * 1024;
    uint j = i ^ sortBlock;
    if (j < i || i >= particleLength) {
        return;
    }
    
    uint key_i = _particleIndexArray[i];
    uint key_j = _particleIndexArray[j];
    float val_i = _cellIndexArray[key_i];
    float val_j = _cellIndexArray[key_j];
    
    if (((val_i - val_j) * ((i & sortDim) == 0 ? 1 : -1)) > 0) {
        _particleIndexArray[i] = key_j;
        _particleIndexArray[j] = key_i;
    }
}

[numthreads(256,1,1)]
void CalculateCellOffsets (uint3 id: SV_DISPATCHTHREADID) {
    uint index = _particleIndexArray[id.x];
    InterlockedMin(_cellOffset[_cellIndexArray[index]], id.x);
}

[numthreads(256,1,1)]
void Integrate (uint3 id: SV_DISPATCHTHREADID) {

    float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce/particleMass)*timestep);
    _particles[id.x].position += vel * timestep;

    float3 topRight = boxSize/2;
    float3 bottomLeft = -boxSize/2;

    // Min Boundary Enforcements
    if (_particles[id.x].position.x - radius < bottomLeft.x) {
        vel.x *= boundDamping;
        _particles[id.x].position.x = bottomLeft.x + boxSize;
    }
    if (_particles[id.x].position.y - radius < bottomLeft.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = bottomLeft.y + radius;
    }
    if (_particles[id.x].position.z - radius < bottomLeft.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = bottomLeft.z + radius;
    }

    // Max Boundary Enforcements
    if (_particles[id.x].position.x + radius > topRight.x) {
        vel.x *= boundDamping;
        _particles[id.x].position.x = topRight.x - radius;
    }
    if (_particles[id.x].position.y + radius > topRight.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = topRight.y - radius;
    }
    if (_particles[id.x].position.z + radius > topRight.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = topRight.z - radius;
    }

    if (distance(_particles[id.x].position, spherePos) + radius < sphereRadius) {
        vel *= boundDamping;
    }

    _particles[id.x].velocity = vel;

}


float StdKernel (float distanceSquared) {
    float x = 1.0f - distanceSquared / radius2;
    return 315.f/ (64.f * pi * radius3) * x * x * x;
}

[numthreads(256,1,1)]
void ComputeDensityPressure (uint3 id: SV_DISPATCHTHREADID) {

    uint index = _particleIndexArray[id.x];
    int3 cellIndex = GetCellVector(_particles[index].position);
    float3 origin = _particles[index].position;
    float sum = 0;

    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            for (int k = -2; k <= 2; k++) {
                int3 neighborIndex = cellIndex + int3(i,j,k);
                uint hashedIndex = CellHash(neighborIndex);
                uint neighborIterator = _cellOffset[hashedIndex];

                while (neighborIterator != 99999999 && neighborIterator < particleLength) {
                    uint particleIndex = _particleIndexArray[neighborIterator];
                    if (_cellIndexArray[particleIndex] != hashedIndex) {
                        break;
                    }
                    Particle neighborParticle = _particles[particleIndex];
                    float3 diff = origin - neighborParticle.position;
                    float distanceSquared = dot(diff, diff);

                    if (radius2*0.004 > distanceSquared*0.004) {

                        sum += StdKernel(distanceSquared * 0.004); // Apply smoothing kernel

                    }

                    neighborIterator++;

                }
            }
        }
    }
    

    _particles[index].density = sum * particleMass + 0.000001f;
    _particles[index].pressure = gasConstant * (_particles[index].density - restDensity);

}

// Smoothing Functions for Compute Forces
float SpikyKernelFirstDerivative (float distance) {
    float x = 1.0f - distance/radius;
    return -45.f/(pi*radius4)*x*x;
}

float SpikyKernelSecondDerivative (float distance) {
    float x = 1.0f - distance/radius;
    return 90.f / (pi*radius5)*x;
}

float3 SpikyKernelGradient (float distance, float3 direction) {
    return SpikyKernelFirstDerivative(distance)*direction;
}

[numthreads(256,1,1)]
void ComputeForces (uint3 id : SV_DISPATCHTHREADID) {

    uint index = _particleIndexArray[id.x];
    int3 cellIndex = GetCellVector(_particles[index].position);
    float3 origin = _particles[index].position;
    float density2 = _particles[index].density * _particles[index].density;
    float mass2 = particleMass * particleMass;
    float3 pressure = float3(0,0,0); // To be calculated
    float3 visc = float3(0,0,0); // To be calculated 
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            for (int k = -2; k <= 2; k++) {
                int3 neighborIndex = cellIndex + int3(i,j,k);
                uint hashedIndex = CellHash(neighborIndex);
                uint neighborIterator = _cellOffset[hashedIndex];

                while (neighborIterator != 99999999 && neighborIterator < particleLength) {
                    uint particleIndex = _particleIndexArray[neighborIterator];
                    if (_cellIndexArray[particleIndex] != hashedIndex) {
                        break;
                    }
                    Particle neighborParticle = _particles[particleIndex];
                    if (origin.x == neighborParticle.position.x && origin.y == neighborParticle.position.y && origin.z == neighborParticle.position.z) {
                        continue;
                    }
                    float dist = distance(neighborParticle.position, origin);
                    if (dist < radius * 2) {
                        float3 pressureGradientDirection = normalize(_particles[index].position - neighborParticle.position);
            
                        float3 _pressureContribution = mass2 * SpikyKernelGradient(dist, pressureGradientDirection);
                        _pressureContribution *= (_particles[index].pressure / density2 + neighborParticle.pressure / (neighborParticle.density * neighborParticle.density));

                        float3 _viscosityContribution = viscosity * mass2 * (neighborParticle.velocity - _particles[index].velocity)/neighborParticle.density;
                        _viscosityContribution *= SpikyKernelSecondDerivative(dist);

                        pressure += _pressureContribution;
                        visc += _viscosityContribution; 
                    }

                    neighborIterator++;

                }
            }
        }
    }

    _particles[index].currentForce = float3(-5,-9.81*particleMass,0) - pressure + visc;

    float3 colDir = _particles[index].position - spherePos;
    if (length(colDir) < sphereRadius) {
        _particles[index].currentForce += colDir * 300;
    }
}